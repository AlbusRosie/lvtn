const BaseIntentHandler = require('./BaseIntentHandler');const BookingHandler = require('../BookingHandler');const BranchHandler = require('../BranchHandler');const BookingValidator = require('../validators/BookingValidator');const Utils = require('../Utils');class BookingIntentHandler extends BaseIntentHandler {    constructor() {        super();        this.intentSet = new Set([            'book_table',            'book_table_partial',            'book_table_specific_branch',            'confirm_booking',            'modify_booking',            'show_booking_info',        ]);    }    canHandle(intent, context = {}) {        if (this.intentSet.has(intent)) {            return true;        }        const lastIntent = context.conversationContext?.lastIntent;        return lastIntent && this.intentSet.has(lastIntent);    }    async handle({ intent, message, context, entities, userId }) {        const normalized = Utils.normalizeEntityFields(entities || {});        const validation = BookingValidator.validate(normalized);        if (intent === 'modify_booking') {            return this.buildResponse({                intent: 'modify_booking',                response: 'Báº¡n muá»‘n thay Ä‘á»•i thÃ´ng tin nÃ o? Vui lÃ²ng cho tÃ´i biáº¿t thÃ´ng tin má»›i báº¡n cáº§n cáº­p nháº­t.',                entities: normalized,                suggestions: [                    { text: 'ğŸ‘¥ Äá»•i sá»‘ ngÆ°á»i', action: 'modify_booking', data: { field: 'people' } },                    { text: 'ğŸ“… Äá»•i ngÃ y', action: 'modify_booking', data: { field: 'date' } },                    { text: 'ğŸ• Äá»•i giá»', action: 'modify_booking', data: { field: 'time' } },                ],            });        }        if (validation.status === 'ask_missing') {            const response = BookingValidator.buildMissingInfoPrompt(validation.missing);            const suggestions = await this._buildBranchSuggestionsIfNeeded(validation);            return this.buildResponse({                intent: 'ask_info',                response,                entities: validation.entities,                suggestions,            });        }        const handlerContext = {            ...context,            conversationContext: {                ...context.conversationContext,                lastEntities: validation.entities,                lastIntent: 'book_table',            },        };        const result = await BookingHandler.handleSmartBooking(message, handlerContext);        if (result?.intent === 'reservation_created' || result?.message || result?.response) {            return result;        }        if (intent === 'confirm_booking') {            return this.buildResponse({                intent: 'book_table',                response: 'Vui lÃ²ng sá»­ dá»¥ng nÃºt "XÃ¡c nháº­n Ä‘áº·t bÃ n" Ä‘á»ƒ hoÃ n táº¥t Ä‘áº·t bÃ n.',                entities: validation.entities,            });        }        if (userId) {            try {                const reservation = await BookingHandler.createActualReservation(userId, validation.entities);                const branchName = validation.entities.branch_name || 'chi nhÃ¡nh Ä‘Ã£ chá»n';                return this.buildResponse({                    intent: 'reservation_created',                    response: `ğŸ‰ Äáº¶T BÃ€N THÃ€NH CÃ”NG!\n\nğŸ‘¥ ${validation.entities.people} ngÆ°á»i\nğŸ“… ${validation.entities.date}\nğŸ• ${validation.entities.time}\nğŸ“ ${branchName}\n\nMÃ£ Ä‘áº·t bÃ n: #${reservation.id}`,                    entities: {                        ...validation.entities,                        reservation_id: reservation.id,                        table_id: reservation.table_id,                        floor_id: reservation.floor_id,                    },                });            } catch (error) {                return this.buildResponse({                    intent: 'reservation_failed',                    response: `âŒ KhÃ´ng thá»ƒ táº¡o Ä‘áº·t bÃ n: ${error.message}`,                    entities: validation.entities,                });            }        }        return null;    }    async _buildBranchSuggestionsIfNeeded(validation) {        if (validation.missing && validation.missing.includes('branch_name')) {            const branches = await BranchHandler.getAllActiveBranches();            if (branches.length === 0) {                return null;            }            return BranchHandler.createBranchSuggestions(branches, {                intent: 'book_table',                ...validation.entities,            });        }        return null;    }}module.exports = BookingIntentHandler;