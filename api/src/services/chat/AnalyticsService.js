const knex = require('../../database/knex');const Logger = require('../../utils/Logger');class AnalyticsService {    constructor() {        this.metrics = {            messageCount: 0,            toolCallCount: 0,            averageResponseTime: 0,        };        this._tableExists = null;         this._tableCheckPromise = null;     }    async _checkTableExists() {        if (this._tableExists !== null) {            return this._tableExists;        }        if (this._tableCheckPromise) {            return this._tableCheckPromise;        }        this._tableCheckPromise = (async () => {            try {                const exists = await knex.schema.hasTable('analytics_events');                this._tableExists = exists;                return exists;            } catch {                this._tableExists = false;                return false;            } finally {                this._tableCheckPromise = null;            }        })();        return this._tableCheckPromise;    }    async trackEvent(userId, eventType, properties = {}) {        try {            const tableExists = await this._checkTableExists();            if (!tableExists) {                return;             }            await knex('analytics_events').insert({                user_id: userId,                event_type: eventType,                properties: JSON.stringify(properties),                created_at: new Date()            });        } catch (error) {            if (error.message && error.message.includes("doesn't exist")) {                this._tableExists = false;                 return;             }            }    }    async trackMessage(userId, conversationId, intent, responseTime, success = true) {        this.metrics.messageCount++;        this.metrics.averageResponseTime =             (this.metrics.averageResponseTime + responseTime) / this.metrics.messageCount;        await this.trackEvent(userId, 'message_processed', {            conversationId,            intent,            responseTime,            success,            timestamp: new Date().toISOString()        });        }    async trackToolCall(userId, toolName, success, duration, error = null) {        this.metrics.toolCallCount++;        await this.trackEvent(userId, 'tool_executed', {            toolName,            success,            duration,            error: error?.message,            timestamp: new Date().toISOString()        });        }    async trackBooking(event, userId, branchId, reservationId = null, details = {}) {        await this.trackEvent(userId, `booking_${event}`, {            branchId,            reservationId,            ...details,            timestamp: new Date().toISOString()        });        }    async getConversationMetrics(startDate, endDate) {        try {            const result = await knex('chat_conversations')                .whereBetween('created_at', [startDate, endDate])                .select(                    knex.raw('COUNT(*) as total_conversations'),                    knex.raw('COUNT(DISTINCT user_id) as unique_users')                );            const messageStats = await knex('chat_messages')                .join('chat_conversations', 'chat_messages.conversation_id', 'chat_conversations.id')                .whereBetween('chat_conversations.created_at', [startDate, endDate])                .select(                    knex.raw('COUNT(*) as total_messages'),                    knex.raw('COUNT(*) / COUNT(DISTINCT conversation_id) as avg_messages_per_conversation')                );            return {                period: { startDate, endDate },                ...result[0],                ...messageStats[0]            };        } catch (error) {            return null;        }    }    async getToolUsageStats(limit = 10) {        try {            const tableExists = await this._checkTableExists();            if (!tableExists) {                return [];             }            const stats = await knex('analytics_events')                .where('event_type', 'tool_executed')                .select(                    knex.raw("JSON_EXTRACT(properties, '$.toolName') as tool_name"),                    knex.raw('COUNT(*) as usage_count'),                    knex.raw("AVG(CAST(JSON_EXTRACT(properties, '$.duration') AS SIGNED)) as avg_duration"),                    knex.raw("SUM(CASE WHEN JSON_EXTRACT(properties, '$.success') = true THEN 1 ELSE 0 END) as success_count"),                    knex.raw("SUM(CASE WHEN JSON_EXTRACT(properties, '$.success') = false THEN 1 ELSE 0 END) as failure_count")                )                .groupBy('tool_name')                .orderBy('usage_count', 'desc')                .limit(limit);            return stats;        } catch (error) {            if (error.message && error.message.includes("doesn't exist")) {                return [];             }            return [];        }    }    async getIntentDistribution(startDate, endDate) {        try {            const tableExists = await this._checkTableExists();            if (!tableExists) {                return [];             }            const stats = await knex('analytics_events')                .where('event_type', 'message_processed')                .whereBetween('created_at', [startDate, endDate])                .select(                    knex.raw("JSON_EXTRACT(properties, '$.intent') as intent"),                    knex.raw('COUNT(*) as count')                )                .groupBy('intent')                .orderBy('count', 'desc');            const total = stats.reduce((sum, stat) => sum + parseInt(stat.count), 0);            return stats.map(stat => ({                intent: JSON.parse(stat.intent),                count: parseInt(stat.count),                percentage: ((parseInt(stat.count) / total) * 100).toFixed(2)            }));        } catch (error) {            if (error.message && error.message.includes("doesn't exist")) {                return [];             }            return [];        }    }    async getResponseTimeMetrics(startDate, endDate) {        try {            const tableExists = await this._checkTableExists();            if (!tableExists) {                return null;             }            const stats = await knex('analytics_events')                .where('event_type', 'message_processed')                .whereBetween('created_at', [startDate, endDate])                .select(                    knex.raw("AVG(CAST(JSON_EXTRACT(properties, '$.responseTime') AS SIGNED)) as avg_response_time"),                    knex.raw("MIN(CAST(JSON_EXTRACT(properties, '$.responseTime') AS SIGNED)) as min_response_time"),                    knex.raw("MAX(CAST(JSON_EXTRACT(properties, '$.responseTime') AS SIGNED)) as max_response_time")                );            return stats[0];        } catch (error) {            if (error.message && error.message.includes("doesn't exist")) {                return null;             }            return null;        }    }    async getBookingConversionRate(startDate, endDate) {        try {            const tableExists = await this._checkTableExists();            if (!tableExists) {                return {                    period: { startDate, endDate },                    bookingIntents: 0,                    bookingsCreated: 0,                    conversionRate: '0%'                };             }            const bookingIntents = await knex('analytics_events')                .where('event_type', 'message_processed')                .whereBetween('created_at', [startDate, endDate])                .whereRaw("JSON_EXTRACT(properties, '$.intent') LIKE '%book_table%'")                .count('* as count');            const bookingCreated = await knex('analytics_events')                .where('event_type', 'booking_created')                .whereBetween('created_at', [startDate, endDate])                .count('* as count');            const intentCount = parseInt(bookingIntents[0].count);            const createdCount = parseInt(bookingCreated[0].count);            const conversionRate = intentCount > 0                 ? ((createdCount / intentCount) * 100).toFixed(2)                 : 0;            return {                period: { startDate, endDate },                bookingIntents: intentCount,                bookingsCreated: createdCount,                conversionRate: `${conversionRate}%`            };        } catch (error) {            if (error.message && error.message.includes("doesn't exist")) {                return {                    period: { startDate, endDate },                    bookingIntents: 0,                    bookingsCreated: 0,                    conversionRate: '0%'                };             }            return null;        }    }    getCurrentMetrics() {        return {            ...this.metrics,            uptime: process.uptime(),            memoryUsage: process.memoryUsage(),            timestamp: new Date().toISOString()        };    }    async healthCheck() {        try {            await knex.raw('SELECT 1');            const AIService = require('./AIService');            const geminiEnabled = AIService.geminiEnabled;            return {                status: 'healthy',                database: 'connected',                gemini: geminiEnabled ? 'enabled' : 'disabled',                uptime: process.uptime(),                timestamp: new Date().toISOString()            };        } catch (error) {            return {                status: 'unhealthy',                error: error.message,                timestamp: new Date().toISOString()            };        }    }}module.exports = new AnalyticsService();