const knex = require('../database/knex');class ReportService {    static async getRevenueReport(filters = {}) {        try {            let dateFrom = filters.date_from;            let dateTo = filters.date_to;            if (!dateFrom || !dateTo) {                const today = new Date();                dateTo = new Date(today);                dateFrom = new Date(today);                dateFrom.setDate(dateFrom.getDate() - 6);                 dateFrom.setHours(0, 0, 0, 0);                dateTo.setHours(23, 59, 59, 999);            }            let dailyQuery = knex('orders')                .where('payment_status', 'paid')                .where('status', 'completed')                .where('total', '>', 0)                 .whereBetween('created_at', [dateFrom, dateTo]);            if (filters.branch_id) {                dailyQuery = dailyQuery.where('branch_id', filters.branch_id);            }            const dailyData = await dailyQuery                .select(                    knex.raw('DATE(created_at) as date'),                    knex.raw('SUM(total) as revenue'),                    knex.raw('COUNT(*) as order_count')                )                .groupBy(knex.raw('DATE(created_at)'))                .orderBy('date', 'asc');            let totalQuery = knex('orders')                .where('payment_status', 'paid')                .where('status', 'completed')                .where('total', '>', 0)                 .whereBetween('created_at', [dateFrom, dateTo]);            if (filters.branch_id) {                totalQuery = totalQuery.where('branch_id', filters.branch_id);            }            const totalResult = await totalQuery                .sum('total as total')                .first();            return {                total: parseFloat(totalResult.total) || 0,                revenue: parseFloat(totalResult.total) || 0,                data: dailyData.map(day => ({                    date: day.date,                    revenue: parseFloat(day.revenue) || 0,                    order_count: parseInt(day.order_count) || 0                }))            };        } catch (error) {            throw new Error(`Failed to get revenue report: ${error.message}`);        }    }    static async getOrderReport(filters = {}) {        try {            let query = knex('orders');            if (filters.branch_id) {                query = query.where('branch_id', filters.branch_id);            }            if (filters.date_from) {                query = query.where('created_at', '>=', filters.date_from);            }            if (filters.date_to) {                query = query.where('created_at', '<=', filters.date_to);            }            if (filters.status) {                query = query.where('status', filters.status);            }            const result = await query                .count('* as total')                .first();            return {                total: parseInt(result.total) || 0,                count: parseInt(result.total) || 0            };        } catch (error) {            throw new Error(`Failed to get order report: ${error.message}`);        }    }    static async getCustomerReport(filters = {}) {        try {            let query = knex('users')                .where('role_id', 4);             if (filters.date_from) {                query = query.where('created_at', '>=', filters.date_from);            }            if (filters.date_to) {                query = query.where('created_at', '<=', filters.date_to);            }            const result = await query                .count('* as total')                .first();            return {                total: parseInt(result.total) || 0,                count: parseInt(result.total) || 0            };        } catch (error) {            throw new Error(`Failed to get customer report: ${error.message}`);        }    }    static async getProductReport(filters = {}) {        try {            let query = knex('products')                .where('status', 'active');            if (filters.category_id) {                query = query.where('category_id', filters.category_id);            }            const result = await query                .count('* as total')                .first();            return {                total: parseInt(result.total) || 0,                count: parseInt(result.total) || 0            };        } catch (error) {            throw new Error(`Failed to get product report: ${error.message}`);        }    }    static async getBranchReport(filters = {}) {        try {            let query = knex('branches')                .where('status', 'active');            const result = await query                .count('* as total')                .first();            return {                total: parseInt(result.total) || 0,                count: parseInt(result.total) || 0            };        } catch (error) {            throw new Error(`Failed to get branch report: ${error.message}`);        }    }    static async getSalesReport(filters = {}) {        try {            let query = knex('orders')                .where('payment_status', 'paid');            if (filters.branch_id) {                query = query.where('branch_id', filters.branch_id);            }            if (filters.date_from) {                query = query.where('created_at', '>=', filters.date_from);            }            if (filters.date_to) {                query = query.where('created_at', '<=', filters.date_to);            }            const result = await query                .sum('total as total')                .count('* as count')                .first();            return {                total: parseFloat(result.total) || 0,                count: parseInt(result.count) || 0,                average: parseFloat(result.total) / (parseInt(result.count) || 1) || 0            };        } catch (error) {            throw new Error(`Failed to get sales report: ${error.message}`);        }    }}module.exports = ReportService;